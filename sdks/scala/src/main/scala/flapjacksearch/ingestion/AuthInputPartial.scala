/** Ingestion API The Ingestion API powers the no-code [data connectors](https://dashboard.flapjack.io/connectors). ##
  * Base URLs Base URLs for the Ingestion API: - `https://data.us.flapjack.io` - `https://data.eu.flapjack.io` Use the
  * URL that matches your [analytics region](https://dashboard.flapjack.io/account/infrastructure/analytics). **All
  * requests must use HTTPS.** ## Authentication Add these headers to authenticate requests: -
  * `x-algolia-application-id`. Your Flapjack application ID. - `x-algolia-api-key`. An API key with the necessary
  * permissions to make the request. The required access control list (ACL) to make a request is listed in each
  * endpoint's reference. You can find your application ID and API key in the [Flapjack
  * dashboard](https://dashboard.flapjack.io/account/api-keys). ## Request format Request bodies must be JSON objects.
  * ## Response status and errors Response bodies are JSON objects. Successful responses return `2xx` statuses. Client
  * errors return `4xx` statuses. Server errors return `5xx` statuses. Error responses have a `message` property with
  * more information. ## Version The current version of the Ingestion API is version 1, indicated by the `/1/` in each
  * endpoint's URL.
  *
  * The version of the OpenAPI document: 1.0.0
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package flapjacksearch.ingestion

import org.json4s._

/** AuthInputPartial
  */
sealed trait AuthInputPartial

trait AuthInputPartialTrait extends AuthInputPartial

object AuthInputPartial {

  case class MapOfStringString(value: Map[String, String]) extends AuthInputPartial

  def apply(value: Map[String, String]): AuthInputPartial = {
    AuthInputPartial.MapOfStringString(value)
  }

}

object AuthInputPartialSerializer extends Serializer[AuthInputPartial] {
  override def deserialize(implicit format: Formats): PartialFunction[(TypeInfo, JValue), AuthInputPartial] = {

    case (TypeInfo(clazz, _), json) if clazz == classOf[AuthInputPartial] =>
      json match {
        case value: JObject if value.obj.exists(_._1 == "clientEmail") =>
          Extraction.extract[AuthGoogleServiceAccountPartial](value)
        case value: JObject if value.obj.exists(_._1 == "username") => Extraction.extract[AuthBasicPartial](value)
        case value: JObject if value.obj.exists(_._1 == "key")      => Extraction.extract[AuthAPIKeyPartial](value)
        case value: JObject if value.obj.exists(_._1 == "url")      => Extraction.extract[AuthOAuthPartial](value)
        case value: JObject                                         => Extraction.extract[AuthFlapjackPartial](value)
        case value: JObject => Extraction.extract[AuthFlapjackInsightsPartial](value)
        case value: JObject => AuthInputPartial.apply(Extraction.extract[Map[String, String]](value))
        case _              => throw new MappingException("Can't convert " + json + " to AuthInputPartial")
      }
  }

  override def serialize(implicit format: Formats): PartialFunction[Any, JValue] = { case value: AuthInputPartial =>
    value match {
      case value: AuthGoogleServiceAccountPartial => Extraction.decompose(value)(format - this)
      case value: AuthBasicPartial                => Extraction.decompose(value)(format - this)
      case value: AuthAPIKeyPartial               => Extraction.decompose(value)(format - this)
      case value: AuthOAuthPartial                => Extraction.decompose(value)(format - this)
      case value: AuthFlapjackPartial              => Extraction.decompose(value)(format - this)
      case value: AuthFlapjackInsightsPartial      => Extraction.decompose(value)(format - this)
      case AuthInputPartial.MapOfStringString(value) =>
        JObject(value.map(kv => JField(kv._1, Extraction.decompose(kv._2)(format))).toList)
    }
  }
}
